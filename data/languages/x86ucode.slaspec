# Basic ================================================================================
define endian=little;
define alignment=0x10;

@define INSTR_LEN 16

define space ucode		type=ram_space size=8 default;
define space register	type=register_space size=2;
define space uram		type=ram_space size=2 wordsize=8;
define space crbus type=ram_space size=2 wordsize=8;
define space mem		type=ram_space size=8 wordsize=1; # physical memory

# fake a stack pointer for the decompilation
define space dummy_space type=ram_space size=2;
define register offset=0xf000 size=8 [dummy_reg];

# Registers ============================================================================
define register offset=0x00 size=8 [
	rax rbx rcx rdx rsp rbp rsi rdi r8 r9 r10 r11 r12 r13 r14 r15 
	tmp0 tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15 
	tmpv0 tmpv1 tmpv2 tmpv3 
	r64dst r64src r64base r64idx
	uip0 uip1
];
# NOTICE: all the instructions filling uop0/uop1 are shown with the ghidra_address (ghidra_address=ucode_address*INSTR_LEN),
# but the pcode uses the ucode_address to preserve correctness
# should fix by setting the ucode wordsize to INSTR_LEN, but it is not supported

define register offset=0x1000 size=16 [
	xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 xmm8 xmm9 xmm10 xmm11 xmm12 xmm13 xmm14 xmm15 
	mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7 
	tmm0 tmm1 tmm2 tmm3 tmm4 tmm5 tmm6 tmm7 
	tmmv0 tmmv1 tmmv2 tmmv3
	xmmdst xmmsrc
];

# tmp0-15 regs have each a flags register
define register offset=0x2000 size=1 [
	tmp0_OF tmp1_OF tmp2_OF tmp3_OF tmp4_OF tmp5_OF tmp6_OF tmp7_OF tmp8_OF tmp9_OF tmp10_OF tmp11_OF tmp12_OF tmp13_OF tmp14_OF tmp15_OF
	tmp0_CF tmp1_CF tmp2_CF tmp3_CF tmp4_CF tmp5_CF tmp6_CF tmp7_CF tmp8_CF tmp9_CF tmp10_CF tmp11_CF tmp12_CF tmp13_CF tmp14_CF tmp15_CF
	tmp0_ZF tmp1_ZF tmp2_ZF tmp3_ZF tmp4_ZF tmp5_ZF tmp6_ZF tmp7_ZF tmp8_ZF tmp9_ZF tmp10_ZF tmp11_ZF tmp12_ZF tmp13_ZF tmp14_ZF tmp15_ZF
	tmp0_SF tmp1_SF tmp2_SF tmp3_SF tmp4_SF tmp5_SF tmp6_SF tmp7_SF tmp8_SF tmp9_SF tmp10_SF tmp11_SF tmp12_SF tmp13_SF tmp14_SF tmp15_SF
	tmp0_PF tmp1_PF tmp2_PF tmp3_PF tmp4_PF tmp5_PF tmp6_PF tmp7_PF tmp8_PF tmp9_PF tmp10_PF tmp11_PF tmp12_PF tmp13_PF tmp14_PF tmp15_PF
	tmpv0_OF tmpv1_OF tmpv2_OF tmpv3_OF
	tmpv0_CF tmpv1_CF tmpv2_CF tmpv3_CF
	tmpv0_ZF tmpv1_ZF tmpv2_ZF tmpv3_ZF
	tmpv0_SF tmpv1_SF tmpv2_SF tmpv3_SF
	tmpv0_PF tmpv1_PF tmpv2_PF tmpv3_PF
	dummy_F
	DF # global direction flag
];

# define macro-instruction data aliases as registers
# each of the register refers to some data in the associated macro-instruction, most are not used, some of them are used but unknown
define register offset=0x3000 size=8 [
	MOP_IMM MOP_01 MOP_02 MOP_03 MOP_RIP MOP_STi MOP_06 MOP_07 MOP_MSLOOPCTR MOP_09 MOP_0a MOP_DATASIZE MOP_0c MOP_0d MOP_0e MOP_0f
	MOP_INSTR MOP_11 MOP_12 MOP_13 MOP_14 MOP_15 MOP_16 MOP_17 MOP_18 MOP_19 MOP_1a MOP_1b MOP_1c MOP_1d MOP_1e MOP_1f
	MOP_20 MOP_21 MOP_22 MOP_23 MOP_24 MOP_25 MOP_26 MOP_27 MOP_28 MOP_29 MOP_2a MOP_2b MOP_2c MOP_2d MOP_2e MOP_2f
	MOP_30 MOP_31 MOP_32 MOP_33 MOP_34 MOP_35 MOP_36 MOP_37 MOP_38 MOP_39 MOP_3a MOP_3b MOP_3c MOP_3d MOP_3e MOP_3f
	MOP_40 MOP_41 MOP_42 MOP_43 MOP_44 MOP_45 MOP_46 MOP_47 MOP_48 MOP_49 MOP_4a MOP_4b MOP_4c MOP_4d MOP_4e MOP_4f
	MOP_50 MOP_51 MOP_52 MOP_53 MOP_54 MOP_55 MOP_56 MOP_57 MOP_58 MOP_59 MOP_5a MOP_5b MOP_5c MOP_5d MOP_5e MOP_5f
	MOP_60 MOP_61 MOP_62 MOP_63 MOP_64 MOP_65 MOP_66 MOP_67 MOP_68 MOP_69 MOP_6a MOP_6b MOP_6c MOP_6d MOP_6e MOP_6f
	MOP_70 MOP_71 MOP_72 MOP_73 MOP_74 MOP_75 MOP_76 MOP_77 MOP_78 MOP_79 MOP_7a MOP_7b MOP_7c MOP_7d MOP_7e MOP_7f
	MOP_80 MOP_81 MOP_82 MOP_83 MOP_84 MOP_85 MOP_86 MOP_87 MOP_88 MOP_89 MOP_8a MOP_8b MOP_8c MOP_8d MOP_8e MOP_8f
	MOP_90 MOP_91 MOP_92 MOP_93 MOP_94 MOP_95 MOP_96 MOP_97 MOP_98 MOP_99 MOP_9a MOP_9b MOP_9c MOP_9d MOP_9e MOP_9f
	MOP_a0 MOP_a1 MOP_a2 MOP_a3 MOP_a4 MOP_a5 MOP_a6 MOP_a7 MOP_a8 MOP_a9 MOP_aa MOP_ab MOP_ac MOP_ad MOP_ae MOP_af
	MOP_b0 MOP_b1 MOP_b2 MOP_b3 MOP_b4 MOP_b5 MOP_b6 MOP_b7 MOP_b8 MOP_b9 MOP_ba MOP_bb MOP_bc MOP_bd MOP_be MOP_bf
	MOP_c0 MOP_c1 MOP_c2 MOP_c3 MOP_c4 MOP_c5 MOP_c6 MOP_c7 MOP_c8 MOP_c9 MOP_ca MOP_cb MOP_cc MOP_cd MOP_ce MOP_cf
	MOP_d0 MOP_d1 MOP_d2 MOP_d3 MOP_d4 MOP_d5 MOP_d6 MOP_d7 MOP_d8 MOP_d9 MOP_da MOP_db MOP_dc MOP_dd MOP_de MOP_df
	MOP_e0 MOP_e1 MOP_e2 MOP_e3 MOP_e4 MOP_e5 MOP_e6 MOP_e7 MOP_e8 MOP_e9 MOP_ea MOP_eb MOP_ec MOP_ed MOP_ee MOP_ef
	MOP_f0 MOP_f1 MOP_f2 MOP_f3 MOP_f4 MOP_f5 MOP_f6 MOP_f7 MOP_f8 MOP_f9 MOP_fa MOP_fb MOP_fc MOP_fd MOP_fe MOP_ff
];

# Fields =================================================================================
define token _uop(64)
	full_uop = (0, 47)
	src0   = (0,  5)
		src0_xmm   = (0,  5)
		src0_sel   = (0,  5)
		src0_OF   = (0,  5)
		src0_CF   = (0,  5)
		src0_ZF   = (0,  5)
		src0_SF   = (0,  5)
		src0_PF   = (0,  5)
	src1   = (6,  11)
		src1_xmm   = (6,  11)
		src1_sel   = (6,  11)
		src1_OF   = (0,  5)
		src1_CF   = (0,  5)
		src1_ZF   = (0,  5)
		src1_SF   = (0,  5)
		src1_PF   = (0,  5)
	dst    = (12, 17)
		dst_xmm    = (12, 17)
		dst_sel    = (12, 17)
		dst_OF    = (12, 17)
		dst_CF    = (12, 17)
		dst_ZF    = (12, 17)
		dst_SF    = (12, 17)
		dst_PF    = (12, 17)
		dst_16    = (16, 16)
	imm1   = (18, 22)
		imm1_sel   = (18, 19)
	m0     = (23, 23)
		uip_reg = (23, 23)
	imm0   = (24, 31)
		imm0_sel0  = (24, 31)
		imm0_sel1  = (24, 31)
		imm0_sel2  = (24, 31)
		imm0_sel3  = (24, 31)
		MOP_alias  = (24, 31)
	opcode = (32, 43)
		dst_size = (38, 39)
		cond_0 = (32,33)
		cond_1 = (36, 36)
		cond_2 = (40, 41)
	m1     = (44, 44)
	m2     = (45, 45)
	uknown = (46, 47)
	is_src0_imm = (48, 48)
	is_src1_imm = (49, 49)
	uop_pad= (48, 63)
;

# ATTACH REGISTER NAMES
attach variables [ src0 src1 ] [ 
	_ r64dst r64src rdi r64base r64idx rdx rdx _ _ _ _ _ _ _ _ _ 
	tmp2 tmp0 tmp7 tmpv0 tmpv1 tmpv2 tmpv3 _ _ _ _ _ _ _ _ 
	rax rcx rdx rbx rsp rbp rsi rdi r8 r9 r10 r11 r12 r13 r14 r15 
	tmp0 tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15
];
attach variables [ src0_xmm src1_xmm ] [ 
	_ xmmdst xmmsrc xmm7 _ _ xmm2 xmm2 _ _ _ _ _ _ _ _ _ 
	mm2 mm0 mm7 tmmv0 tmmv1 tmmv2 tmmv3 _ _ _ _ _ _ _ _ 
	xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 xmm8 xmm9 xmm10 xmm11 xmm12 xmm13 xmm14 xmm15 
	mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7 tmm0 tmm1 tmm2 tmm3 tmm4 tmm5 tmm6 tmm7
];

attach variables [ dst ] [ 
	dummy_reg r64dst rax rdi rax rax rdx rdx tmp0 tmp7 tmp0 tmp0 tmp0 tmp7 tmp0 tmp0 
	_ tmp2 tmp0 tmp7 tmpv0 tmpv1 tmpv2 tmpv3 tmp0 tmp7 tmp0 tmp0 tmp0 tmp7 tmp0 tmp0 
	rax rcx rdx rbx rsp rbp rsi rdi r8 r9 r10 r11 r12 r13 r14 r15 
	tmp0 tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15
];
attach variables [ dst_xmm ] [ 
	_ xmm2 xmm0 xmm7 xmm0 xmm0 xmm2 xmm2 mm0 mm7 mm0 mm0 mm0 mm7 mm0 mm0 _ 
	mm2 mm0 mm7 tmmv0 tmmv1 tmmv2 tmmv3 mm0 mm7 mm0 mm0 mm0 mm7 mm0 mm0 
	xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 xmm8 xmm9 xmm10 xmm11 xmm12 xmm13 xmm14 xmm15 
	mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7 tmm0 tmm1 tmm2 tmm3 tmm4 tmm5 tmm6 tmm7
];

# attach tmp flags
attach variables [ dst_OF src0_OF src1_OF ] [ 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F tmp0_OF tmp7_OF tmp0_OF tmp0_OF tmp0_OF tmp7_OF tmp0_OF tmp0_OF 
    _ tmp2_OF tmp0_OF tmp7_OF tmpv0_OF tmpv1_OF tmpv2_OF tmpv3_OF tmp0_OF tmp7_OF tmp0_OF tmp0_OF tmp0_OF tmp7_OF tmp0_OF tmp0_OF 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F 
    tmp0_OF tmp1_OF tmp2_OF tmp3_OF tmp4_OF tmp5_OF tmp6_OF tmp7_OF tmp8_OF tmp9_OF tmp10_OF tmp11_OF tmp12_OF tmp13_OF tmp14_OF tmp15_OF
];
attach variables [ dst_CF src0_CF src1_CF ] [ 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F tmp0_CF tmp7_CF tmp0_CF tmp0_CF tmp0_CF tmp7_CF tmp0_CF tmp0_CF 
    _ tmp2_CF tmp0_CF tmp7_CF tmpv0_CF tmpv1_CF tmpv2_CF tmpv3_CF tmp0_CF tmp7_CF tmp0_CF tmp0_CF tmp0_CF tmp7_CF tmp0_CF tmp0_CF 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F 
    tmp0_CF tmp1_CF tmp2_CF tmp3_CF tmp4_CF tmp5_CF tmp6_CF tmp7_CF tmp8_CF tmp9_CF tmp10_CF tmp11_CF tmp12_CF tmp13_CF tmp14_CF tmp15_CF
];
attach variables [ dst_ZF src0_ZF src1_ZF ] [ 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F tmp0_ZF tmp7_ZF tmp0_ZF tmp0_ZF tmp0_ZF tmp7_ZF tmp0_ZF tmp0_ZF 
    _ tmp2_ZF tmp0_ZF tmp7_ZF tmpv0_ZF tmpv1_ZF tmpv2_ZF tmpv3_ZF tmp0_ZF tmp7_ZF tmp0_ZF tmp0_ZF tmp0_ZF tmp7_ZF tmp0_ZF tmp0_ZF 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F 
    tmp0_ZF tmp1_ZF tmp2_ZF tmp3_ZF tmp4_ZF tmp5_ZF tmp6_ZF tmp7_ZF tmp8_ZF tmp9_ZF tmp10_ZF tmp11_ZF tmp12_ZF tmp13_ZF tmp14_ZF tmp15_ZF
];
attach variables [ dst_SF src0_SF src1_SF ] [ 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F tmp0_SF tmp7_SF tmp0_SF tmp0_SF tmp0_SF tmp7_SF tmp0_SF tmp0_SF 
    _ tmp2_SF tmp0_SF tmp7_SF tmpv0_SF tmpv1_SF tmpv2_SF tmpv3_SF tmp0_SF tmp7_SF tmp0_SF tmp0_SF tmp0_SF tmp7_SF tmp0_SF tmp0_SF 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F 
    tmp0_SF tmp1_SF tmp2_SF tmp3_SF tmp4_SF tmp5_SF tmp6_SF tmp7_SF tmp8_SF tmp9_SF tmp10_SF tmp11_SF tmp12_SF tmp13_SF tmp14_SF tmp15_SF
];
attach variables [ dst_PF src0_PF src1_PF ] [ 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F tmp0_PF tmp7_PF tmp0_PF tmp0_PF tmp0_PF tmp7_PF tmp0_PF tmp0_PF 
    _ tmp2_PF tmp0_PF tmp7_PF tmpv0_PF tmpv1_PF tmpv2_PF tmpv3_PF tmp0_PF tmp7_PF tmp0_PF tmp0_PF tmp0_PF tmp7_PF tmp0_PF tmp0_PF 
    dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F dummy_F 
    tmp0_PF tmp1_PF tmp2_PF tmp3_PF tmp4_PF tmp5_PF tmp6_PF tmp7_PF tmp8_PF tmp9_PF tmp10_PF tmp11_PF tmp12_PF tmp13_PF tmp14_PF tmp15_PF
];

attach names [dst_size] [
	"32" "64" "16" "8" 
];

attach variables [uip_reg] [uip0 uip1];

# create the 4 tables to express hardcoded immediates
attach values [imm0_sel0] [
	0x1 0x2 0x3 0x4 0x8 0x10 0x1f 0x20 0x24 0x40 0x7f 0x80 0x100 0x1bf 0x200 0x301 
	0x341 0x381 0x400 0x404 0x504 0x800 0x9bf 0xfff 0x1000 0x11fb 0x1f80 0x2000 0x4000 0x591c 0x6000 0x7000 
	0x7800 0x7c00 0x7c04 0x7e00 0x7f00 0x7f80 0x8000 0x8001 0x8008 0x8009 0x8080 0xa09b 0xb615 0xc000 0xc001 0xc09b 
	0xc802 0xe000 0xe904 0xf000 0xf800 0xfade 0xfc00 0xfc01 0xfe00 0xff00 0xff80 0xff81 0xffb9 0xffbb 0xffc0 0xffd7 
	0xffe0 0xfff0 0xfff8 0xfffc 0xfffd 0xfffe 0xffff 0x10000 0x10003 0x10004 0x10006 0x10007 0x10008 0x1000a 0x1000b 0x1000d 
	0x1000e 0x1000f 0x10011 0x10013 0x10014 0x10015 0x10018 0x1001e 0x1003a 0x1003e 0x10203 0x10300 0x10800 0x11000 0x13fff 0x14000 
	0x14809 0x16809 0x18000 0x18009 0x19ffe 0x1c000 0x1e000 0x1f000 0x1f800 0x1fc00 0x1fe00 0x1ff00 0x1ff80 0x1ffc0 0x1ffe0 0x1fff0 
	0x1fff8 0x1fffc 0x1fffe 0x1ffff 0x20000 0x20003 0x2001b 0x2001c 0x20020 0x20101 0x20200 0x30000 0x30012 0x30036 0x3003f 0x30101 
	0x3017f 0x30200 0x30300 0x30400 0x30600 0x34100 0x36dfb 0x36dff 0x38000 0x38003 0x3c000 0x3e000 0x3efc4 0x3f000 0x3f800 0x3fc00 
	0x3fe00 0x3ff00 0x3ff80 0x3ffc0 0x3ffc1 0x3ffe0 0x3fff0 0x3fff8 0x3fffc 0x3ffff 0x40000 0x40001 0x50000 0x50300 0x506c0 0x60000 
	0x61101 0x70000 0x78000 0x7c000 0x7e000 0x7f000 0x7f800 0x7fc00 0x7fe00 0x7ff00 0x7ff80 0x7ffc0 0x7ffe0 0x7fff0 0x7fff8 0x80000 
	0x80001 0x8000f 0x84400 0x90000 0x90100 0x9cdfd 0xc0000 0xe0000 0xe88c8 0xf0000 0xf8000 0xfc000 0xfe000 0xff000 0xff800 0xffc00 
	0xffe00 0xfff00 0xfff80 0xfffc0 0xfffe0 0xffff0 0xffff8 0xfffff 0x100000 0x1000b0 0x110016 0x110017 0x110406 0x140000 0x15a7ff 0x180000 
	0x1a3202 0x1c0000 0x1dcfff 0x1e0000 0x1f0000 0x1f8000 0x1fc000 0x1fe000 0x1ff000 0x1ff800 0x1ffc00 0x1ffe00 0x1fff00 0x1fff80 0x1fffc0 0x1fffe0 
	0x1fffff 0x200000 0x2001c1 0x200201 0x254500 0x254dd5 0x254fd5 0x257700 0x257fd5 0x2c6000 0x2c6800 0x300000 0x380000 0x3c0000 0x3c4dd7 0x3c7fd7 
	0x3dcfff 0x3e0000 0x3f0000 0x3f3fd7 0x3f7700 0x3f7fd5 0x3f8000 0x3fc000 0x3fe000 0x3ff000 0x3ff800 0x3ffc00 0x3ffe00 0x3fff00 0x3fff80 0x3fffc0
];
attach values [imm0_sel1] [
	0x400000 0x400001 0x4001c1 0x400281 0x4002c1 0x4004c1 0x400501 0x400541 0x400601 0x410000 0x520201 0x523000 0x523300 0x523700 0x5a0201 0x600000 
	0x600201 0x640fa0 0x700000 0x700084 0x780000 0x790484 0x7c0000 0x7dafdf 0x7e0000 0x7f0000 0x7f8000 0x7fc000 0x7fcfcc 0x7fe000 0x7ff000 0x7ff800 
	0x7ffc00 0x7ffe00 0x7fff00 0x7fff80 0x7fffff 0x800000 0x800002 0x800012 0x811088 0x830c00 0x830f00 0xc00000 0xc41089 0xda0400 0xe00000 0xf00000 
	0xf80000 0xfc0000 0xfe0000 0xff0000 0xff8000 0xffc000 0xffe000 0xfff000 0xfff800 0xfffc00 0xfffe00 0xffff00 0xffffff 0x1000000 0x1800000 0x1c00000 
	0x1e00000 0x1f00000 0x1f80000 0x1fc0000 0x1fe0000 0x1ff0000 0x1ff8000 0x1ffc000 0x1ffe000 0x1fff000 0x1fff800 0x1fffc00 0x1fffe00 0x1ffffff 0x2000000 0x3000000 
	0x3030303 0x30fc000 0x3800000 0x388e90c 0x3c00000 0x3e00000 0x3e80190 0x3f00000 0x3f80000 0x3fc0000 0x3fe0000 0x3ff0000 0x3ff8000 0x3ffc000 0x3ffe000 0x3fff000 
	0x3fff800 0x3fffc00 0x4000000 0x4006172 0x401e172 0x4040404 0x4050607 0x4066173 0x4400581 0x44005c1 0x4410141 0x6000000 0x6334141 0x7000000 0x7800000 0x7c00000 
	0x7e00000 0x7f00000 0x7f80000 0x7fc0000 0x7fe0000 0x7ff0000 0x7ff8000 0x7ffc000 0x7ffe000 0x7fff000 0x7fff800 0x8000000 0x8000040 0x8090a0b 0xb180000 0xb1a0000 
	0xc000000 0xc0d0e0f 0xe000000 0xe351212 0xf000000 0xf800000 0xfc00000 0xfe00000 0xff00000 0xff80000 0xffc0000 0xffe0000 0xfff0000 0xfff8000 0xfffc000 0xfffe000 
	0xffff000 0xfffffff 0x10000000 0x1003fff7 0x11242020 0x11242120 0x18000000 0x1c000000 0x1d90453a 0x1e000000 0x1f000000 0x1f800000 0x1f83d9ab 0x1fc00000 0x1fe00000 0x1ff00000 
	0x1ff80000 0x1ffc0000 0x1ffe0000 0x1fff0000 0x1fff8000 0x1fffc000 0x1fffe000 0x20000000 0x200fffff 0x2020205f 0x28000000 0x2e140788 0x30000000 0x38000000 0x3c000000 0x3c6ef372 
	0x3e000000 0x3f000000 0x3f1586cb 0x3f800000 0x3fc00000 0x3fe00000 0x3ff00000 0x3ff80000 0x3ffc0000 0x3ffe0000 0x3fff0000 0x3fff8000 0x3fffc000 0x3ffff000 0x40000000 0x40000003 
	0x4000004c 0x40004658 0x40004680 0x400046f0 0x40004e00 0x40004e80 0x4000506c 0x400050a0 0x400050e4 0x40005110 0x40005114 0x40005140 0x40005144 0x41b7b4a1 0x41b96981 0x41ff0100 
	0x41ff01ff 0x4959f260 0x49656e69 0x50000000 0x510e527f 0x5449465f 0x5be0cd19 0xed17ed0 0x60000000 0x600401e7 0x6004c1e7 0x6a09673c 0x6a09e667 0x6c65746e 0x6ea2ea0f 0x70000000 
	0x756e6547 0x78000000 0x7c000000 0x7e000000 0x7f000000 0x7f800000 0x7fc00000 0x7fe00000 0x7ff00000 0x7ff80000 0x7ffc0000 0x7ffe0000 0x7fff0000 0x7fff8000 0x7ffff000 0x7ffffc00 
	0x80000000 0x80000001 0x8000000d 0x80000021 0x80000033 0x80000301 0x80000501 0x80000603 0x80000700 0x80000701 0x80000b0e 0x8000f0c0 0x8000f0e0 0x8005003f 0x80fffffc 0x817f20e0
];
attach values [imm0_sel2] [
	0x817f40c0 0x817f40e0 0x90810720 0xed17ed0 0x9b05688c 0xed17ed0 0xa0000000 0xa00f001e 0xa54ff53a 0xa8000040 0xaa000000 0xed17ed0 0xae84cbf5 0xb28fb7b5 0xbb67ae85 0xbe8b7112 
	0xc0000000 0xc0000040 0xc0000100 0xc0000f80 0xc0001fff 0xdbdc0f7f 0xe0000000 0xe0000001 0xe005003f 0xe6acf082 0xe859631e 0xf0000000 0xf04d766e 0xf0841070 0xf12ddfef 0xf293b606 
	0xf2c5a1d9 0xf700d000 0xf8000000 0xf8f8f8f8 0xf93d2a54 0xfc000000 0xfe000000 0xfe036dfb 0xfeb00000 0xfeb80000 0xfeb83b80 0xfeb83ba0 0xfed20e00 0xff000000 0xff800000 0xffc00000 
	0xffc0802a 0xffca5800 0xffca7800 0xffdbb22a 0xffe00000 0xffe21000 0xffe29000 0xffead800 0xfff00000 0xfff101ff 0xfff80000 0xfff9fffe 0xfffaffff 0xfffc0000 0xfffc11fb 0xfffe0000 
	0xfffeffff 0xffff0000 0xffff0ff0 0xffff2bff 0xffffc000 0xffffe90c 0xffffff00 0xffffffb0 0xffffffc0 0xffffffc8 0xffffffff 0xc 0x20008 0x20800 0x2282b 0x100408 
	0x3c491c 0x523380 0x20b8000 0x40007fff 0x90810200 0xd600d000 0xf0840070 0xffc21000 0xfff300f8 0xffff0180 0x1fffffff 0xffff57dc 0xffff3efe 0xffffd1f0 0x7dffffff 0xfffff7de 
	0xffffffff 0xfffff809 0xff7f8050 0xfffff8ff 0xfffffffe 0xffffc800 0xffffe000 0xfffffffb 0xffffffc0 0xffffffc8 0xfffffff9 0xfeb9ffac 0xfed3ff88 0xff03ffc0 0xff83ffe9 0xffd1fff8 
	0x3ffdfffe 0x3fdbfffc 0xffcbfffa 0xffdbffff 0xbfe30200 0xffe2d003 0xffe6907b 0xffead81c 0xfff300f8 0xffff01ff 0xfffffffd 0xffffdffe 0xfffb0efe 0xffffd1b6 0xffff7dff 0xffff55dd 
	0x817f41ff 0x817f42e0 0x90830720 0x994b66a2 0x9b076e8c 0x9db3770e 0xa0036dfb 0xa00f6dff 0xa54ff53a 0xa8038003 0xaa03c000 0xab13e80b 0xae87eff5 0xb28ff6b5 0xbb67fc85 0xbe8bfd12 
	0xc003fe00 0xc003ff40 0xc003ff80 0xc003ffc0 0xc003fffb 0xdbdfffff 0xe003fff0 0xe003fff1 0xe007ffff 0xe6afffff 0xe85d631e 0xf0040001 0xf04d366e 0xf0851370 0xf12d9fef 0xf297b606 
	0xf2c7b1d9 0xf707d000 0xf8078000 0xf8ffd8f8 0xf93fea54 0xfc07f000 0xfe07f800 0xfe07fdfb 0xfeb7fe00 0xfebfff00 0xfebfff80 0xfebfffe0 0xfed7ffe0 0xff07fff0 0xff87fff8 0xffc80000 
	0xffc8802b 0xffca580f 0xffca7c00 0xffdb922a 0xffe90100 0xffebd5fd 0xffee9000 0xffeed800 0xfffe88c8 0xffff01ff 0xffff8000 0xffffdefe 0xffffee46 0xfffff000 0xfffff9fb 0xfffffc00 
	0xffffffff 0xffffff00 0xfffffff0 0xffffffff 0xffffffe0 0xfffffff0 0xfffffff8 0xffffffff 0xffffffc0 0xfffffff8 0xffffffff 0x10001c 0x13040e 0x160800 0x17afff 0x180408 
	0x3e7b1e 0x5e3380 0x21fcfee 0x401e7fff 0x909f0200 0xd61fd000 0xf09fc070 0xffdff000 0xfffff0f8 0xfffff980 0x1ffffdfd 0xffffffdc 0xfffffffe 0xfffffff0 0x7dffffff 0xfffffffe 
	0xffffffff 0xffffd000 0xff7e01d1 0xfffffaff 0xffffef54 0xffffcdd5 0xffffcfd5 0xfffffffb 0xffffffd5 0xffffffc8 0xfffffff9 0xfeb83bac 0xfefa0e08 0xff3e0800 0xffbe6dff 0xfffc7fdf 
	0x3ffdcfff 0x3ffe7b80 0xfffff800 0xffffffff 0xbfff7700 0xffffffd5 0xffff9070 0xffffd800 0xffffe0f8 0xfffff1ff 0xfffffdfd 0xfffffffe 0xfffffefe 0xffffff80 0xffffffff 0xffffffdc
];
attach values [imm0_sel3] [
	0x817f40c0 0x817f40e1 0x90c107e1 0x994866a3 0x9b456acd 0x9df277cf 0xa0400501 0xa04f055f 0xa54ff73b 0xa8410000 0xaa520201 0xab53780b 0xaed6fbf5 0xb2dfb7b5 0xbb7fae85 0xbeeb7112 
	0xc0600201 0xc0640fe0 0xc0700100 0xc0700f80 0xc0781afb 0xdbfd0fff 0xe07c0000 0xe07dafdf 0xe07f003f 0xe6fff082 0xe87fe31e 0xf07fc000 0xf07fffee 0xf0fff070 0xf17fdfef 0xf2fffe06 
	0xf2ffa5d9 0xf77fd600 0xf87f8700 0xf8ffdff8 0xf97faaff 0xfc800000 0xfe800002 0xfe836dfb 0xfeb11088 0xfebb0c00 0xfebb3f80 0xfef83ba0 0xfed61e89 0xffda0400 0xffe00000 0xfff00000 
	0xfff8802a 0xfffe5800 0xfffe7800 0xffff922a 0xffff8000 0xffffd000 0xfffff000 0xfffff800 0xfffff800 0xfffffdff 0xfffffe00 0xfffffffe 0xffffffff 0xfffc0000 0xfffc11fb 0xfffe0000 
	0xfffeffff 0xffff0000 0xffff0770 0xffff207f 0xffffc000 0xffffc800 0xffffc000 0xffffffb0 0xffffffc0 0xffffffc8 0xfffffff9 0x1fffc0c 0x1fffe08 0x1ffffff 0x2022829 0x3100408 
	0x33f4b1f 0x35ff380 0x38b8000 0x4388ffff 0x93c10200 0xd7e0d000 0xf3ec01f0 0xfff21000 0xfffb00f8 0xffff0180 0x1ffffdfd 0xffff55dc 0xffffb6fe 0xffffd1f0 0x7fffffff 0xfffff7de 
	0xffffffff 0xfffffc00 0xff7e0050 0xfffff9ff 0xffffeb76 0xffffcc04 0xffffc607 0xfffffffb 0xffffffc1 0xffffffc9 0xfffffff9 0xfeb83bac 0xfef34f49 0xff020800 0xff822829 0xffd00408 
	0x3ffcc93e 0x3ffa7b80 0xfffbf800 0xfffff27f 0xbfff0200 0xffffd000 0xffff9070 0xffffd800 0xffffe0f8 0xfffff1ff 0xfffffdfd 0xffffdffe 0xfffb0efe 0xffffdb8b 0xfffe7dff 0xffff55dc 
	0x8d7f40c0 0x8d7f4eef 0x9e810720 0x9f7d76b2 0x9f05688c 0x9fb2770e 0xafc00000 0xafef001e 0xaffff53a 0xaff80000 0xaffc0000 0xafff680b 0xafffcaf5 0xbfffb6b5 0xbfffec85 0xbffff112 
	0xcffff000 0xcfffffff 0xd0000100 0xd003fff7 0xd1243afb 0xdbfc2f7f 0xf8000000 0xfc000001 0xfd95453f 0xfeacf082 0xff59631e 0xff800000 0xffcfffef 0xffc41070 0xffed9fef 0xfff3b606 
	0xfffda1d9 0xfffcd000 0xfffe0000 0xffffd8f8 0xffffaa54 0xffffc000 0xffffe000 0xfe036dfb 0xfebfffff 0xfeb8205f 0xfeb83b80 0xfebc3fa8 0xfed20e00 0xff000000 0xff800000 0xffeef372 
	0xffc0802a 0xffca5800 0xffdffecb 0xffdb922a 0xffe00000 0xffe21000 0xfff29000 0xfffad800 0xfffc0000 0xffff01ff 0xffff0000 0xffffdefe 0xffffce46 0xfffff000 0xfffc11fb 0xfffe0003 
	0xfffeffff 0xffff4658 0xffff47f0 0xffff66ff 0xffffce00 0xffffce80 0xffffd06c 0xffffffb0 0xffffffe4 0xffffffd8 0xfffffffd 0x4000514c 0x4002514c 0x41b7bca1 0x41bb69a9 0x41ff0508 
	0x41ff49ff 0x495bf3e0 0x4b6fee69 0x50007fff 0xd18f527f 0xd649d65f 0xfbe4cd79 0xfff6919e 0xfff300f8 0xffff01e7 0x7ffffdff 0xffff77fc 0xfffff6ff 0xfffff5fe 0x7fffffff 0xfffff7de 
	0xffffffff 0xffffd000 0xff7e0050 0xfffff8ff 0xffffea54 0xffffc800 0xffffc000 0xfffffffb 0xffffffc0 0xffffffc8 0xfffffff9 0xfffe3bac 0xffff0e08 0xffff8800 0xfffff829 0xfffffc08 
	0xbffcc93e 0xbfda7b81 0xffcbf80d 0xffdbf27f 0xbfe10233 0xffe2d301 0xffe69571 0xffeade03 0xfff307f8 0xffff07ff 0xffffffff 0xfffffffe 0xfffbfefe 0xffffd1bf 0xffffffff 0xffff75fc
];

attach variables [MOP_alias] [
	MOP_IMM MOP_01 MOP_02 MOP_03 MOP_RIP MOP_STi MOP_06 MOP_07 MOP_MSLOOPCTR MOP_09 MOP_0a MOP_DATASIZE MOP_0c MOP_0d MOP_0e MOP_0f
	MOP_INSTR MOP_11 MOP_12 MOP_13 MOP_14 MOP_15 MOP_16 MOP_17 MOP_18 MOP_19 MOP_1a MOP_1b MOP_1c MOP_1d MOP_1e MOP_1f
	MOP_20 MOP_21 MOP_22 MOP_23 MOP_24 MOP_25 MOP_26 MOP_27 MOP_28 MOP_29 MOP_2a MOP_2b MOP_2c MOP_2d MOP_2e MOP_2f
	MOP_30 MOP_31 MOP_32 MOP_33 MOP_34 MOP_35 MOP_36 MOP_37 MOP_38 MOP_39 MOP_3a MOP_3b MOP_3c MOP_3d MOP_3e MOP_3f
	MOP_40 MOP_41 MOP_42 MOP_43 MOP_44 MOP_45 MOP_46 MOP_47 MOP_48 MOP_49 MOP_4a MOP_4b MOP_4c MOP_4d MOP_4e MOP_4f
	MOP_50 MOP_51 MOP_52 MOP_53 MOP_54 MOP_55 MOP_56 MOP_57 MOP_58 MOP_59 MOP_5a MOP_5b MOP_5c MOP_5d MOP_5e MOP_5f
	MOP_60 MOP_61 MOP_62 MOP_63 MOP_64 MOP_65 MOP_66 MOP_67 MOP_68 MOP_69 MOP_6a MOP_6b MOP_6c MOP_6d MOP_6e MOP_6f
	MOP_70 MOP_71 MOP_72 MOP_73 MOP_74 MOP_75 MOP_76 MOP_77 MOP_78 MOP_79 MOP_7a MOP_7b MOP_7c MOP_7d MOP_7e MOP_7f
	MOP_80 MOP_81 MOP_82 MOP_83 MOP_84 MOP_85 MOP_86 MOP_87 MOP_88 MOP_89 MOP_8a MOP_8b MOP_8c MOP_8d MOP_8e MOP_8f
	MOP_90 MOP_91 MOP_92 MOP_93 MOP_94 MOP_95 MOP_96 MOP_97 MOP_98 MOP_99 MOP_9a MOP_9b MOP_9c MOP_9d MOP_9e MOP_9f
	MOP_a0 MOP_a1 MOP_a2 MOP_a3 MOP_a4 MOP_a5 MOP_a6 MOP_a7 MOP_a8 MOP_a9 MOP_aa MOP_ab MOP_ac MOP_ad MOP_ae MOP_af
	MOP_b0 MOP_b1 MOP_b2 MOP_b3 MOP_b4 MOP_b5 MOP_b6 MOP_b7 MOP_b8 MOP_b9 MOP_ba MOP_bb MOP_bc MOP_bd MOP_be MOP_bf
	MOP_c0 MOP_c1 MOP_c2 MOP_c3 MOP_c4 MOP_c5 MOP_c6 MOP_c7 MOP_c8 MOP_c9 MOP_ca MOP_cb MOP_cc MOP_cd MOP_ce MOP_cf
	MOP_d0 MOP_d1 MOP_d2 MOP_d3 MOP_d4 MOP_d5 MOP_d6 MOP_d7 MOP_d8 MOP_d9 MOP_da MOP_db MOP_dc MOP_dd MOP_de MOP_df
	MOP_e0 MOP_e1 MOP_e2 MOP_e3 MOP_e4 MOP_e5 MOP_e6 MOP_e7 MOP_e8 MOP_e9 MOP_ea MOP_eb MOP_ec MOP_ed MOP_ee MOP_ef
	MOP_f0 MOP_f1 MOP_f2 MOP_f3 MOP_f4 MOP_f5 MOP_f6 MOP_f7 MOP_f8 MOP_f9 MOP_fa MOP_fb MOP_fc MOP_fd MOP_fe MOP_ff
];

define token _seqword(64)
	full_seqword = (0, 31)
	up0        = (0, 1)
	eflow      = (2, 5)
		eflow_cmd = (2, 5)
	up1        = (6, 7)
	next_uaddr = (8, 22)
	up2        = (23, 24)
	sync       = (25, 27)
		sync_cmd  = (25, 27)
	unknown2   = (28, 29)
	seq_pad0   = (30, 31)
	with_testustate = (32, 32)
	seq_pad1   = (33 ,63)
;
# TODO: with strings you cannot express pcode semantics
attach names [sync_cmd] [
	"UNKNOWN_SYNC" "LFNCEWAIT" "LFNCEMARK" "LFNCEWTMRK" "SYNCFULL" "SYNCWAIT" "SYNCMARK" "SYNCWTMRK"
];
attach names [eflow_cmd] [
	"UNKNOWN_EFLOW" "UNKNOWN_EFLOW" "SEQW URET0" "SEQW URET1" "SEQW SAVEUIP0" "SEQW SAVEUIP1" "SEQW SAVEUIP0" "SEQW SAVEUIP1"
	"WRTAGW" "MSLOOP" "UNKNOWN_EFLOW" "MSSTOP" "SEQW UEND0" "SEQW UEND1" "SEQW UEND2" "SEQW UEND3"
];

# ======= MACROS =======
macro resultflags(result, ZF, SF, PF) {
 SF = result s< 0;
 ZF = result == 0;
 PF = ((popcount(result & 0xff) & 1:1) == 0);
 # AF not implemented
}
macro addflags(op1, op2, OF, CF) {
 CF = carry(op1,op2);
 OF = scarry(op1,op2);
}

macro subflags(op1, op2, OF, CF) {
 CF = op1 < op2;
 OF = sborrow(op1,op2);
}

macro negflags(op1, OF, CF) {
 CF = (op1 != 0);
 OF = sborrow(0,op1);
}

macro logicalflags(OF, CF) {
 CF = 0;
 OF = 0;
}

#macro imultflags(low,total){
#  CF = sext(low) != total;
#  OF = CF;
#}
#
#macro multflags(highhalf) {
# CF = highhalf != 0;
# OF = CF;
#}

macro rolflags(result, count, OF, CF) {

 local notzero = (count != 0);
 local newCF = ((result & 1) != 0);
 CF = (!notzero & CF) | (notzero & newCF);

 local one = (count == 1);
 local newOF = CF ^ (result s< 0);
 OF = (!one & OF) | (one & newOF);
}

macro rorflags(result, count, OF, CF) {

 local notzero = (count != 0);
 local newCF = (result s< 0);
 CF = (!notzero & CF) | (notzero & newCF);

 local one = (count == 1);
 local newOF = (result s< 0) ^ ((result << 1) s< 0);
 OF = (!one & OF) | (one & newOF);
}
macro shiftresultflags(result, count, ZF, SF, PF) {

 local notzero = (count != 0);

 local newSF = (result s< 0);
 SF = (!notzero & SF) | (notzero & newSF);

 local newZF = (result == 0);
 ZF = (!notzero & ZF) | (notzero & newZF);
 
 local newPF = ((popcount(result & 0xff) & 1:1) == 0);
 PF = (!notzero & PF) | (notzero & newPF);
 # AF not implemented
}
macro shlflags(op1,result,count, OF, CF) { # works for shld also

 local notzero = (count != 0);
 local newCF = ( (op1 << (count - 1)) s< 0 );
 CF = (!notzero & CF) | (notzero & newCF);

 local one = (count == 1);
 local newOF = CF ^ (result s< 0);
 OF = (!one & OF) | (one & newOF);
}

macro sarflags(op1,result,count, OF, CF) {

 local notzero = (count != 0);
 local newCF = ( ( (op1 s>> (count - 1)) & 1 ) != 0 );
 CF = (!notzero & CF) | (notzero & newCF);

 local one = (count == 1);
 OF = (!one & OF);
}

macro shrflags(op1,result,count, OF, CF) {

 local notzero = (count != 0);
 local newCF = ( ( (op1 >> (count - 1)) & 1 ) != 0 );
 CF = (!notzero & CF) | (notzero & newCF);

 local one = (count == 1);
 local newOF = (op1 s< 0);
 OF = (!one & OF) | (one & newOF);
}

# ======= SEQWORD =======
# TODO: differentiate between seqword_before and seqword_after!! Otherwise the pcode for things like saveuip will be wrong
seqword_sync: [sync_cmd] is up2=1 & sync_cmd {}
seqword_sync:"" is up2=0 & sync {}

# UEND: think of a better way to express end
seqword_eflow:"; "^eflow_cmd is up0=1 & (eflow=12 | eflow=13 | eflow=14 |eflow=15) & eflow_cmd { return [0:8];}

seqword_eflow:"; SEQW URET0" is up0=1 & eflow=2 { return [uip0 * $(INSTR_LEN)]; }
seqword_eflow:"; SEQW URET1" is up0=1 & eflow=3 { return [uip1 * $(INSTR_LEN)]; }
# SAVEUIP
seqword_next:next is up0=1 [ next = inst_next; ] {
  export *[ucode]:8 next;
}
seqword_eflow:"; SEQW SAVEUIP0" seqword_next is up0=1 & eflow=4 & seqword_next { uip0 = inst_next/$(INSTR_LEN); }
seqword_eflow:"; SEQW SAVEUIP1" seqword_next is up0=1 & eflow=5 & seqword_next { uip1 = inst_next/$(INSTR_LEN); }
# TODO: what does ROVR do?
seqword_eflow:"; ROVR<- SEQW SAVEUIP0" seqword_next is up0=1 & eflow=6 & seqword_next{ uip0 = inst_next/$(INSTR_LEN); }
seqword_eflow:"; ROVR<- SEQW SAVEUIP1" seqword_next is up0=1 & eflow=7 & seqword_next { uip1 = inst_next/$(INSTR_LEN); }

seqword_eflow:"; "^eflow_cmd is up0=1 & eflow_cmd {}
seqword_eflow:"" is up0=1 & eflow=0 {}
seqword_eflow:"" is up0=0 & eflow {}

# TODO: express conditional execution of goto with testustate
seqword_target: target is next_uaddr [ target = next_uaddr*$(INSTR_LEN); ] {
  export *[ucode]:8 target;
}
seqword_goto:"; SEQW GOTO" seqword_target is up1=1 & seqword_target {
	goto seqword_target;
}
seqword_goto:"" is up1=0 & next_uaddr {}

seqword:""^seqword_eflow^seqword_goto^seqword_sync is seqword_eflow & seqword_goto & seqword_sync {
	build seqword_sync;
	build seqword_eflow;
	build seqword_goto;
}
seqword:"" is full_seqword=0 {}


# ======= UOP =======
# deal with sources or immediates
source0: src0 is src0 & src0_sel { export src0; }
source0: imm0_sel0 is m0=0 & imm0_sel0 & imm1_sel=0 & src0_sel = 16 {export *[const]:8 imm0_sel0;}
source0: imm0_sel1 is m0=0 & imm0_sel1 & imm1_sel=1 & src0_sel = 16 {export *[const]:8 imm0_sel1;}
source0: imm0_sel2 is m0=0 & imm0_sel2 & imm1_sel=2 & src0_sel = 16 {export *[const]:8 imm0_sel2;}
source0: imm0_sel3 is m0=0 & imm0_sel3 & imm1_sel=3 & src0_sel = 16 {export *[const]:8 imm0_sel3;}
source0: immediate is m0=0 & src0_sel = 0 & src0_sel [ immediate = 0; ] { export *[const]:8 immediate; }
source0: immediate is m0=0 & imm0 & imm1 & (src0_sel = 8 | src0_sel = 9 | src0_sel = 10 | src0_sel = 11 | src0_sel = 12 | src0_sel = 13 | src0_sel = 14 | src0_sel = 15 | src0_sel = 24 | src0_sel = 25 | src0_sel = 26 | src0_sel = 27 | src0_sel = 28 | src0_sel = 29 | src0_sel = 30 | src0_sel = 31) & src0_sel [
	immediate = 0xffffffffffff0000 * ((src0_sel & 0x10) >> 4) | ((src0_sel & 0x07) << 13) | (imm1 << 8) | imm0;
] { export *[const]:8 immediate; }
source0: MOP_alias is m0=1 & MOP_alias & (src0_sel = 0 | src0_sel = 16 | src0_sel = 8 | src0_sel = 9 | src0_sel = 10 | src0_sel = 11 | src0_sel = 12 | src0_sel = 13 | src0_sel = 14 | src0_sel = 15 | src0_sel = 24 | src0_sel = 25 | src0_sel = 26 | src0_sel = 27 | src0_sel = 28 | src0_sel = 29 | src0_sel = 30 | src0_sel = 31) & src0_sel { 
	export MOP_alias;
}
# parse source0 as a target in the ucode
source0_target_imm: imm0_sel0 is imm0_sel0 & imm1_sel=0 & src0_sel = 16 {local tmp=imm0_sel0*$(INSTR_LEN):8; export *[ucode]:8 tmp;}
source0_target_imm: imm0_sel1 is imm0_sel1 & imm1_sel=1 & src0_sel = 16 {local tmp=imm0_sel1*$(INSTR_LEN):8; export *[ucode]:8 tmp;}
source0_target_imm: imm0_sel2 is imm0_sel2 & imm1_sel=2 & src0_sel = 16 {local tmp=imm0_sel2*$(INSTR_LEN):8; export *[ucode]:8 tmp;}
source0_target_imm: imm0_sel3 is imm0_sel3 & imm1_sel=3 & src0_sel = 16 {local tmp=imm0_sel3*$(INSTR_LEN):8; export *[ucode]:8 tmp;}
source0_target_imm: immediate is imm0 & imm1 & (src0_sel = 8 | src0_sel = 9 | src0_sel = 10 | src0_sel = 11 | src0_sel = 12 | src0_sel = 13 | src0_sel = 14 | src0_sel = 15 | src0_sel = 24 | src0_sel = 25 | src0_sel = 26 | src0_sel = 27 | src0_sel = 28 | src0_sel = 29 | src0_sel = 30 | src0_sel = 31) & src0_sel [
	immediate = (0xffffffffffff0000 * ((src0_sel & 0x10) >> 4) | ((src0_sel & 0x07) << 13) | (imm1 << 8) | imm0)*$(INSTR_LEN);
] { export *[ucode]:8 immediate; }

source1: src1 is src1 & src1_sel { export src1; }
source1: imm0_sel0 is m0=0 & imm0_sel0 & imm1_sel=0 & src1_sel = 16 {export *[const]:8 imm0_sel0;}
source1: imm0_sel1 is m0=0 & imm0_sel1 & imm1_sel=1 & src1_sel = 16 {export *[const]:8 imm0_sel1;}
source1: imm0_sel2 is m0=0 & imm0_sel2 & imm1_sel=2 & src1_sel = 16 {export *[const]:8 imm0_sel2;}
source1: imm0_sel3 is m0=0 & imm0_sel3 & imm1_sel=3 & src1_sel = 16 {export *[const]:8 imm0_sel3;}
source1: immediate is m0=0 & src1_sel = 0 & src1_sel [ immediate = 0; ] { export *[const]:8 immediate; }
source1: immediate is m0=0 & imm0 & imm1 & (src1_sel = 8 | src1_sel = 9 | src1_sel = 10 | src1_sel = 11 | src1_sel = 12 | src1_sel = 13 | src1_sel = 14 | src1_sel = 15 | src1_sel = 24 | src1_sel = 25 | src1_sel = 26 | src1_sel = 27 | src1_sel = 28 | src1_sel = 29 | src1_sel = 30 | src1_sel = 31) & src1_sel [
	immediate = 0xffffffffffff0000 * ((src1_sel & 0x10) >> 4) | ((src1_sel & 0x07) << 13) | (imm1 << 8) | imm0;
] { export *[const]:8 immediate; }
source1: MOP_alias is m0=1 & MOP_alias & (src1_sel = 0 | src1_sel = 16 | src1_sel = 8 | src1_sel = 9 | src1_sel = 10 | src1_sel = 11 | src1_sel = 12 | src1_sel = 13 | src1_sel = 14 | src1_sel = 15 | src1_sel = 24 | src1_sel = 25 | src1_sel = 26 | src1_sel = 27 | src1_sel = 28 | src1_sel = 29 | src1_sel = 30 | src1_sel = 31) & src1_sel {
	export MOP_alias;
}
# parse source1 as a target in the ucode
source1_target_imm: imm0_sel0 is imm0_sel0 & imm1_sel=0 & src1_sel = 16 {local tmp=imm0_sel0*$(INSTR_LEN):8; export *[ucode]:8 tmp;}
source1_target_imm: imm0_sel1 is imm0_sel1 & imm1_sel=1 & src1_sel = 16 {local tmp=imm0_sel1*$(INSTR_LEN):8; export *[ucode]:8 tmp;}
source1_target_imm: imm0_sel2 is imm0_sel2 & imm1_sel=2 & src1_sel = 16 {local tmp=imm0_sel2*$(INSTR_LEN):8; export *[ucode]:8 tmp;}
source1_target_imm: imm0_sel3 is imm0_sel3 & imm1_sel=3 & src1_sel = 16 {local tmp=imm0_sel3*$(INSTR_LEN):8; export *[ucode]:8 tmp;}
source1_target_imm: immediate is imm0 & imm1 & (src1_sel = 0 | src1_sel = 8 | src1_sel = 9 | src1_sel = 10 | src1_sel = 11 | src1_sel = 12 | src1_sel = 13 | src1_sel = 14 | src1_sel = 15 | src1_sel = 24 | src1_sel = 25 | src1_sel = 26 | src1_sel = 27 | src1_sel = 28 | src1_sel = 29 | src1_sel = 30 | src1_sel = 31) & src1_sel [
	immediate = (0xffffffffffff0000 * ((src1_sel & 0x10) >> 4) | ((src1_sel & 0x07) << 13) | (imm1 << 8) | imm0)*$(INSTR_LEN);
] { export *[ucode]:8 immediate; }

dest: dst <- is dst & dst_sel { export dst; }
dest: is dst & dst_sel=0 { export dst; }

# FLAGS CONDITION CODES
# NOTICE: UJMPCC_DIRECT_TAKEN_CONDZ is the only one that does not respect the reverse-engineered cc pattern, no idea why
cc:"o"^is  cond_0=0 & cond_1=1 & cond_2=0 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { export src0_OF; }
cc:"no"^is cond_0=1 & cond_1=1 & cond_2=0 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = !src0_OF; export tmp; }
cc:"b"^is  cond_0=2 & cond_1=1 & cond_2=0 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { export src0_CF; }
cc:"ae"^is cond_0=3 & cond_1=1 & cond_2=0 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = !src0_CF; export tmp; }
cc:"z"^is  cond_0=0 & cond_1=1 & cond_2=1 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { export src0_ZF; }
cc:"nz"^is cond_0=1 & cond_1=1 & cond_2=1 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = !src0_ZF; export tmp; }
cc:"be"^is cond_0=2 & cond_1=1 & cond_2=1 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = src0_CF || src0_ZF; export tmp; }
cc:"a"^is  cond_0=3 & cond_1=1 & cond_2=1 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = !(src0_CF || src0_ZF); export tmp; }
cc:"d"^is  cond_0=1 & cond_1=0 & cond_2=1 {export DF;}
cc:"s"^is  cond_0=0 & cond_1=1 & cond_2=2 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { export src0_SF; }
cc:"ns"^is cond_0=1 & cond_1=1 & cond_2=2 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = !src0_SF; export tmp; }
cc:"p"^is  cond_0=2 & cond_1=1 & cond_2=2 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { export src0_PF; }
cc:"np"^is cond_0=3 & cond_1=1 & cond_2=2 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = !src0_PF; export tmp; }
cc:"l"^is  cond_0=0 & cond_1=1 & cond_2=3 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = src0_OF != src0_SF; export tmp; }
cc:"ge"^is cond_0=1 & cond_1=1 & cond_2=3 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = src0_OF == src0_SF; export tmp; }
cc:"le"^is cond_0=2 & cond_1=1 & cond_2=3 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = src0_ZF || (src0_OF != src0_SF); export tmp; }
cc:"g"^is  cond_0=3 & cond_1=1 & cond_2=3 & src0_OF & src0_CF & src0_ZF & src0_SF & src0_PF { local tmp = !src0_ZF && (src0_OF == src0_SF); export tmp; }

define pcodeop unknown;
:UNKNOWN opcode: dst_sel <- src0_sel, src1_sel, imm0, imm1 seqword is opcode & dst_sel & src0_sel & src1_sel & imm0 & imm1; seqword {
	unknown(opcode:8, dst_sel:8, src0_sel:8, src1_sel:8, imm0:8, imm1:8);
	build seqword;
}

# instructions TODO: fix semantics, rflags, and different sizes
:nop seqword is full_uop=0; seqword {}

:add^"_"^dst_size dest source0, source1 seqword is (opcode = 0x000 | opcode = 0x040 | opcode = 0x080 | opcode = 0x0c0) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	addflags(source0, source1, dst_OF, dst_CF);
	dest = source0 + source1;
	resultflags(dest, dst_ZF,dst_SF, dst_PF);
	build seqword;
}

:or^"_"^dst_size dest source0, source1 seqword is (opcode = 0x001 | opcode = 0x041 | opcode = 0x081 | opcode = 0x0c1) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	logicalflags(dst_OF, dst_CF);
	dest = source0 | source1;
	resultflags(dest, dst_ZF,dst_SF, dst_PF);
	build seqword;
}

:and^"_"^dst_size dest source0, source1 seqword is (opcode = 0x004 | opcode = 0x044 | opcode = 0x084 | opcode = 0x0c4) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	logicalflags(dst_OF, dst_CF);
	dest = source0 & source1;
	resultflags(dest, dst_ZF,dst_SF, dst_PF);
	build seqword;
}

:sub^"_"^dst_size dest source0, source1 seqword is (opcode = 0x005 | opcode = 0x045 | opcode = 0x085 | opcode = 0x0c5) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	subflags(source0, source1, dst_OF, dst_CF);
	dest = source0 - source1;
	resultflags(dest, dst_ZF,dst_SF, dst_PF);
	build seqword;
}

:xor^"_"^dst_size dest source0, source1 seqword is (opcode = 0x006 | opcode = 0x046 | opcode = 0x086 | opcode = 0x0c6) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	logicalflags(dst_OF, dst_CF);
	dest = source0 ^ source1;
	resultflags(dest, dst_ZF,dst_SF, dst_PF);
	build seqword;
}

:shl^"_"^dst_size dest source0, source1 seqword is (opcode = 0x024 | opcode = 0x064 | opcode = 0x0a4 | opcode = 0x0e4) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	# TODO: mask for cnt should be based on bitsize
	local cnt = source1 & 0x3f;
	local tmp = source0;
	dest = source0 << source1;
	shlflags(tmp, dest, cnt, dst_OF, dst_CF);
	shiftresultflags(dest, cnt, dst_ZF, dst_SF, dst_PF);
	build seqword;
}

:shr^"_"^dst_size dest source0, source1 seqword is (opcode = 0x025 | opcode = 0x065 | opcode = 0x0a5 | opcode = 0x0e5) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	# TODO: mask for cnt should be based on bitsize
	local cnt = source1 & 0x3f;
	local tmp = source0;
	dest = source0 >> source1;
	shrflags(tmp, dest, cnt, dst_OF, dst_CF);
	shiftresultflags(dest, cnt, dst_ZF, dst_SF, dst_PF);
	build seqword;
}

:sar^"_"^dst_size dest source0, source1 seqword is (opcode = 0x02e | opcode = 0x06e | opcode = 0x0ae | opcode = 0x0ee) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	# TODO: mask for cnt should be based on bitsize
	local cnt = source1 & 0x3f;
	local tmp = source0;
	dest = source0 s>> source1;
	sarflags(tmp, dest, cnt, dst_OF, dst_CF);
	shiftresultflags(dest, cnt, dst_ZF, dst_SF, dst_PF);
	build seqword;
}

:rol^"_"^dst_size dest source0, source1 seqword is (opcode = 0x02c | opcode = 0x06c | opcode = 0x0ac | opcode = 0x0ec) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	# TODO: mask for cnt should be based on bitsize
	local cnt = source1 & 0x3f;
	dest = (source0 << source1) | (source0 >> (64 - source1));
	rolflags(dest, cnt, dst_OF, dst_CF);
	build seqword;
}

:ror^"_"^dst_size dest source0, source1 seqword is (opcode = 0x02d | opcode = 0x06d | opcode = 0x0ad | opcode = 0x0ed) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	# TODO: mask for cnt should be based on bitsize
	local cnt = source1 & 0x3f;
	dest = (source0 >> source1) | (source0 << (64 - source1));
	rolflags(dest, cnt, dst_OF, dst_CF);
	build seqword;
}

:notand^"_"^dst_size dest source0, source1 seqword is (opcode = 0x007 | opcode = 0x047 | opcode = 0x087 | opcode = 0x0c7) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	negflags(source0 & source1, dst_OF, dst_CF);
	dest = ~(source0 & source1);
	resultflags(dest, dst_ZF,dst_SF, dst_PF);
	build seqword;
}

:zeroext^"_"^dst_size dest source0 seqword is (opcode = 0x008 | opcode = 0x048 | opcode = 0x088 | opcode = 0x0c8) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & dst_size; seqword {
	dest = source0;
	build seqword;
}

:mov^"_"^dst_size dest source0 seqword is (opcode = 0x009 | opcode = 0x049) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & dst_size; seqword {
	dest = source0;
	build seqword;
}

#TODO: should bts/btr/btc opperation clear the source0 or dest bit?
:bt^"_"^dst_size dest source0, source1 seqword is  (opcode = 0x014 | opcode = 0x054 | opcode = 0x094) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	# TODO: mask for cnt should be based on bitsize
	local cnt = source1 & 0x3f;
	local cf = (source0 >> cnt) & 1;
	dst_CF = cf:1;
	build seqword;
}
:bts^"_"^dst_size dest source0, source1 seqword is (opcode = 0x015 | opcode = 0x055 | opcode = 0x095) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	# TODO: mask for cnt should be based on bitsize
	local cnt = source1 & 0x3f;
	local cf = (source0 >> cnt) & 1;
	dst_CF = cf:1;
	dest = source0 | (1:8 << cnt);
	build seqword;
}
:btr^"_"^dst_size dest source0, source1 seqword is (opcode = 0x016 | opcode = 0x056 | opcode = 0x096) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	# TODO: mask for cnt should be based on bitsize
	local cnt = source1 & 0x3f;
	local cf = (source0 >> cnt) & 1;
	dst_CF = cf:1;
	dest = source0 & ~(1:8 << cnt);
	build seqword;
}
:btc^"_"^dst_size dest source0, source1 seqword is (opcode = 0x017 | opcode = 0x057 | opcode = 0x097) & dest & dst_OF & dst_CF & dst_ZF & dst_SF & dst_PF & source0 & source1 & dst_size; seqword {
	# TODO: mask for cnt should be based on bitsize
	local cnt = source1 & 0x3f;
	local cf = (source0 >> cnt) & 1;
	dst_CF = cf:1;
	dest = source0 ^ (1:8 << cnt);
	build seqword;
}

:sel^cc^"_"^dst_size dest source0, source1 seqword is (opcode = 0x030 | opcode = 0x031 | opcode = 0x032 | opcode = 0x033 | opcode = 0x070 | opcode = 0x071 | opcode = 0x072 | opcode = 0x073 | opcode = 0x130 | opcode = 0x131 | opcode = 0x132 | opcode = 0x133 | opcode = 0x170 | opcode = 0x171 | opcode = 0x172 | opcode = 0x173 | opcode = 0x230 | opcode = 0x231 | opcode = 0x232 | opcode = 0x233 | opcode = 0x270 | opcode = 0x271 | opcode = 0x272 | opcode = 0x273 | opcode = 0x330 | opcode = 0x331 | opcode = 0x332 | opcode = 0x333 | opcode = 0x370 | opcode = 0x371 | opcode = 0x372 | opcode = 0x373) & dest & cc & source0 & source1 & dst_size; seqword {
	local res = 0:8;
	if (!cc) goto <done>;
	res = source1;
	<done>
	dest = res;
	build seqword;
}

:cmov^cc^"_"^dst_size dest source0, source1 seqword is (opcode=0x034 | opcode=0x035 | opcode=0x036 | opcode=0x037 | opcode=0x074 | opcode=0x075 | opcode=0x076 | opcode=0x077 | opcode=0x0b4 | opcode=0x0b5 | opcode=0x0b6 | opcode=0x0b7 | opcode=0x0f4 | opcode=0x0f5 | opcode=0x0f6 | opcode=0x0f7 | opcode=0x134 | opcode=0x135 | opcode=0x136 | opcode=0x137 | opcode=0x174 | opcode=0x175 | opcode=0x176 | opcode=0x177 | opcode=0x1b4 | opcode=0x1b5 | opcode=0x1b6 | opcode=0x1b7 | opcode=0x1f4 | opcode=0x1f5 | opcode=0x1f6 | opcode=0x1f7 | opcode=0x234 | opcode=0x235 | opcode=0x236 | opcode=0x237 | opcode=0x274 | opcode=0x275 | opcode=0x276 | opcode=0x277 | opcode=0x2b4 | opcode=0x2b5 | opcode=0x2b6 | opcode=0x2b7 | opcode=0x2f4 | opcode=0x2f5 | opcode=0x2f6 | opcode=0x2f7 | opcode=0x334 | opcode=0x335 | opcode=0x336 | opcode=0x337 | opcode=0x374 | opcode=0x375 | opcode=0x376 | opcode=0x377 | opcode=0x3b4 | opcode=0x3b5 | opcode=0x3b6 | opcode=0x3b7 | opcode=0x3f4 | opcode=0x3f5 | opcode=0x3f6 | opcode=0x3f7) & dest & cc & source0 & source1 & dst_size; seqword {
	local res = source1;
	if (!cc) goto <done>;
	res = source0;
	<done>
	dest = res;
	build seqword;
}

# cannot cast/reuse source0/1 since for the immediate we have to &0x1ff, and the disasm view does not support operations on subtables
source0_uram: src0 is src0 & src0_sel { export *[uram]:8 src0; }
source0_uram: imm0_sel0 is imm0_sel0 & imm1_sel=0 & src0_sel = 16 {export *[uram]:8 imm0_sel0;}
source0_uram: imm0_sel1 is imm0_sel1 & imm1_sel=1 & src0_sel = 16 {export *[uram]:8 imm0_sel1;}
source0_uram: imm0_sel2 is imm0_sel2 & imm1_sel=2 & src0_sel = 16 {export *[uram]:8 imm0_sel2;}
source0_uram: imm0_sel3 is imm0_sel3 & imm1_sel=3 & src0_sel = 16 {export *[uram]:8 imm0_sel3;}
source0_uram: immediate is imm0 & imm1 & (src0_sel = 8 | src0_sel = 9 | src0_sel = 10 | src0_sel = 11 | src0_sel = 12 | src0_sel = 13 | src0_sel = 14 | src0_sel = 15 | src0_sel = 24 | src0_sel = 25 | src0_sel = 26 | src0_sel = 27 | src0_sel = 28 | src0_sel = 29 | src0_sel = 30 | src0_sel = 31) & src0_sel [
	immediate = (0xffffffffffff0000 * ((src0_sel & 0x10) >> 4) | ((src0_sel & 0x07) << 13) | (imm1 << 8) | imm0) & 0x1ff;
] { export *[uram]:8 immediate; }
source1_uram: src1 is src1 & src1_sel { export *[uram]:8 src1; }
source1_uram: imm0_sel0 is imm0_sel0 & imm1_sel=0 & src1_sel = 16 {export *[uram]:8 imm0_sel0;}
source1_uram: imm0_sel1 is imm0_sel1 & imm1_sel=1 & src1_sel = 16 {export *[uram]:8 imm0_sel1;}
source1_uram: imm0_sel2 is imm0_sel2 & imm1_sel=2 & src1_sel = 16 {export *[uram]:8 imm0_sel2;}
source1_uram: imm0_sel3 is imm0_sel3 & imm1_sel=3 & src1_sel = 16 {export *[uram]:8 imm0_sel3;}
source1_uram: immediate is imm0 & imm1 & (src1_sel = 8 | src1_sel = 9 | src1_sel = 10 | src1_sel = 11 | src1_sel = 12 | src1_sel = 13 | src1_sel = 14 | src1_sel = 15 | src1_sel = 24 | src1_sel = 25 | src1_sel = 26 | src1_sel = 27 | src1_sel = 28 | src1_sel = 29 | src1_sel = 30 | src1_sel = 31) & src1_sel [
	immediate = (0xffffffffffff0000 * ((src1_sel & 0x10) >> 4) | ((src1_sel & 0x07) << 13) | (imm1 << 8) | imm0) & 0x1ff;
] { export *[uram]:8 immediate; }
single_uram_source:source0_uram^is src1_sel=0 & source0_uram {export source0_uram;}
single_uram_source:source1_uram^is src0_sel=0 & source1_uram {export source1_uram;}
:ruram dest single_uram_source seqword is opcode = 0x063 & dest & single_uram_source; seqword {
	dest = single_uram_source;
	build seqword;
}
# TODO: some writeuram uops have also dest, wtf
:wuram source0, source1_uram seqword is opcode = 0x043 & dest & source0 & source1_uram; seqword {
	source1_uram = source0;
	build seqword;
}

# crbs operations
# cannot cast/reuse source0/1 since for the immediate we have to &0x7ff, and the disasm view does not support operations on subtables
source0_crbus: src0 is src0 & src0_sel { export *[crbus]:8 src0; }
source0_crbus: crbus_addr is imm0_sel0 & imm1_sel=0 & src0_sel = 16 [crbus_addr = imm0_sel0 & 0x7ff;] {export *[crbus]:8 crbus_addr;}
source0_crbus: crbus_addr is imm0_sel1 & imm1_sel=1 & src0_sel = 16 [crbus_addr = imm0_sel1 & 0x7ff;] {export *[crbus]:8 crbus_addr;}
source0_crbus: crbus_addr is imm0_sel2 & imm1_sel=2 & src0_sel = 16 [crbus_addr = imm0_sel2 & 0x7ff;] {export *[crbus]:8 crbus_addr;}
source0_crbus: crbus_addr is imm0_sel3 & imm1_sel=3 & src0_sel = 16 [crbus_addr = imm0_sel3 & 0x7ff;] {export *[crbus]:8 crbus_addr;}
source0_crbus: immediate is src0_sel = 0 & src0_sel [ immediate = 0; ] { export *[crbus]:8 immediate; }
source0_crbus: immediate is imm0 & imm1 & (src0_sel = 8 | src0_sel = 9 | src0_sel = 10 | src0_sel = 11 | src0_sel = 12 | src0_sel = 13 | src0_sel = 14 | src0_sel = 15 | src0_sel = 24 | src0_sel = 25 | src0_sel = 26 | src0_sel = 27 | src0_sel = 28 | src0_sel = 29 | src0_sel = 30 | src0_sel = 31) & src0_sel [
	immediate = (((src0_sel & 0x07) << 13) | (imm1 << 8) | imm0) & 0x7ff;
] { export *[crbus]:8 immediate; }
source1_crbus: src1 is src1 & src1_sel { export *[crbus]:8 src1; }
source1_crbus: crbus_addr is imm0_sel0 & imm1_sel=0 & src1_sel = 16 [crbus_addr = imm0_sel0 & 0x7ff;] {export *[crbus]:8 crbus_addr;}
source1_crbus: crbus_addr is imm0_sel1 & imm1_sel=1 & src1_sel = 16 [crbus_addr = imm0_sel1 & 0x7ff;] {export *[crbus]:8 crbus_addr;}
source1_crbus: crbus_addr is imm0_sel2 & imm1_sel=2 & src1_sel = 16 [crbus_addr = imm0_sel2 & 0x7ff;] {export *[crbus]:8 crbus_addr;}
source1_crbus: crbus_addr is imm0_sel3 & imm1_sel=3 & src1_sel = 16 [crbus_addr = imm0_sel3 & 0x7ff;] {export *[crbus]:8 crbus_addr;}
source1_crbus: immediate is src1_sel = 0 & src1_sel [ immediate = 0; ] { export *[crbus]:8 immediate; }
source1_crbus: immediate is imm0 & imm1 & (src1_sel = 8 | src1_sel = 9 | src1_sel = 10 | src1_sel = 11 | src1_sel = 12 | src1_sel = 13 | src1_sel = 14 | src1_sel = 15 | src1_sel = 24 | src1_sel = 25 | src1_sel = 26 | src1_sel = 27 | src1_sel = 28 | src1_sel = 29 | src1_sel = 30 | src1_sel = 31) & src1_sel [
	immediate = (((src1_sel & 0x07) << 13) | (imm1 << 8) | imm0) & 0x7ff;
] { export *[crbus]:8 immediate; }
single_crbus_source:source0_crbus^is src1_sel=0 & source0_crbus {export source0_crbus;}
single_crbus_source:source1_crbus^is src0_sel=0 & source1_crbus {export source1_crbus;}

:rcreg dest single_crbus_source seqword is opcode = 0x062 & dest & single_crbus_source; seqword {
	dest = single_crbus_source;
	build seqword;
}
# TODO: some writeuram uops have also dest, wtf
:wcreg source0, source1_crbus seqword is opcode = 0x042 & dest & source0 & source1_crbus; seqword {
	source1_crbus = source0;
	build seqword;
}


# direct conditional jump
:ujmp^cc source0, source1_target_imm seqword is (is_src1_imm=1 | (src1_sel=0 & is_src1_imm=0)) & (opcode=0x050 | opcode=0x051 | opcode=0x052 | opcode=0x053 | opcode=0x150 | opcode=0x151 | opcode=0x152 | opcode=0x153 | opcode=0x250 | opcode=0x251 | opcode=0x252 | opcode=0x253 | opcode=0x350 | opcode=0x351 | opcode=0x352 | opcode=0x353) & cc & source0 & source1_target_imm; seqword {
	if (cc) goto source1_target_imm;
	build seqword;
}
# indirect jump
:ujmp^cc source0, source1 seqword is is_src1_imm=0 & (opcode=0x050 | opcode=0x051 | opcode=0x052 | opcode=0x053 | opcode=0x150 | opcode=0x151 | opcode=0x152 | opcode=0x153 | opcode=0x250 | opcode=0x251 | opcode=0x252 | opcode=0x253 | opcode=0x350 | opcode=0x351 | opcode=0x352 | opcode=0x353) & cc & source0 & source1; seqword {
	local target = source1 * $(INSTR_LEN);
	if (!cc) goto <nojump>;
	goto [target];
	<nojump>
	build seqword;
}
# UJMPCC_DIRECT_TAKEN_CONDZ
:ujmpz_t source0, source1_target_imm seqword is (is_src1_imm=1 | (src1_sel=0 & is_src1_imm=0)) & opcode=0x15f & source0 & source1_target_imm & src0_ZF; seqword {
	if (src0_ZF) goto source1_target_imm;
	build seqword;
}
# indirect jump
:ujmpz_t source0, source1 seqword is is_src1_imm=0 & opcode=0x15f & source0 & source1 & src0_ZF; seqword {
	local target = source1 * $(INSTR_LEN);
	if (!src0_ZF) goto <nojump>;
	goto [target];
	<nojump>
	build seqword;
}
#ujmp
:ujmp source1_target_imm seqword is (is_src1_imm=1 | (src1_sel=0 & is_src1_imm=0)) & opcode=0x15d & source1_target_imm; seqword {
	goto source1_target_imm;
	build seqword;
}
# indirect ujmp
:ujmp source1 seqword is is_src1_imm=0 & opcode=0x15d & source1; seqword {
	local target = source1 * $(INSTR_LEN);
	goto [target];
	build seqword;
}

source1_cmpj: src1 is src1 & src1_sel { export *[crbus]:8 src1; }
source1_cmpj: first_imm is imm0_sel0 & imm1_sel=0 & src1_sel = 16 [first_imm = (imm0_sel0) >> 15;] {export *[const]:8 first_imm;}
source1_cmpj: first_imm is imm0_sel1 & imm1_sel=1 & src1_sel = 16 [first_imm = (imm0_sel1) >> 15;] {export *[const]:8 first_imm;}
source1_cmpj: first_imm is imm0_sel2 & imm1_sel=2 & src1_sel = 16 [first_imm = (imm0_sel2) >> 15;] {export *[const]:8 first_imm;}
source1_cmpj: first_imm is imm0_sel3 & imm1_sel=3 & src1_sel = 16 [first_imm = (imm0_sel3) >> 15;] {export *[const]:8 first_imm;}
source1_cmpj: immediate is src1_sel = 0 & src1_sel [ immediate = 0; ] { export *[const]:8 immediate; }
source1_cmpj: immediate is imm0 & imm1 & m0 & (src1_sel = 8 | src1_sel = 9 | src1_sel = 10 | src1_sel = 11 | src1_sel = 12 | src1_sel = 13 | src1_sel = 14 | src1_sel = 15 | src1_sel = 24 | src1_sel = 25 | src1_sel = 26 | src1_sel = 27 | src1_sel = 28 | src1_sel = 29 | src1_sel = 30 | src1_sel = 31) & src1_sel [
	immediate = (((src1_sel & 0x10) << 1) | ((src1_sel & 0x07) << 2) | (imm1 >> 4) | (m0 << 1));
] { export *[const]:8 immediate; }
cmpj_target: second_imm is imm0_sel0 & imm1_sel=0 & src1_sel = 16 [second_imm = (imm0_sel0 & 0x7fff) | 0x20;] {export *[ucode]:8 second_imm;}
cmpj_target: second_imm is imm0_sel1 & imm1_sel=1 & src1_sel = 16 [second_imm = (imm0_sel1 & 0x7fff) | 0x20;] {export *[ucode]:8 second_imm;}
cmpj_target: second_imm is imm0_sel2 & imm1_sel=2 & src1_sel = 16 [second_imm = (imm0_sel2 & 0x7fff) | 0x20;] {export *[ucode]:8 second_imm;}
cmpj_target: second_imm is imm0_sel3 & imm1_sel=3 & src1_sel = 16 [second_imm = (imm0_sel3 & 0x7fff) | 0x20;] {export *[ucode]:8 second_imm;}
cmpj_target: immediate is imm1_sel & src1_sel & imm0 & imm1 & m1 & m2 & dst_16 [
#    immediate = ((full_uop & 0x10000) >> 2) | ((full_uop & 0x100000000000) >> 31) | ((full_uop & 0x200000000000) >> 33) | \
#                     ((full_uop & 0x3c0000) >> 10) | ((full_uop & 0xff000000) >> 24)
    immediate = ((dst_16 << 14) | (m1 << 13) | (m2 << 12) | ((imm1 & 0xff) << 8) | imm0) * $(INSTR_LEN);
] { export *[ucode]:8 immediate; }
# cmp & jump
:cmpjb source0, source1_cmpj, cmpj_target seqword is opcode=0x86a & source0 & source1_cmpj & cmpj_target; seqword {
	if (source0 < source1_cmpj) goto cmpj_target;
	build seqword;
}
:cmpjbe source0, source1_cmpj, cmpj_target seqword is opcode=0x86b & source0 & source1_cmpj & cmpj_target; seqword {
	if (source0 <= source1_cmpj) goto cmpj_target;
	build seqword;
}
:cmpjz source0, source1_cmpj, cmpj_target seqword is opcode=0x928 & source0 & source1_cmpj & cmpj_target; seqword {
	if (source0 == source1_cmpj) goto cmpj_target;
	build seqword;
}
:cmpjnz source0, source1_cmpj, cmpj_target seqword is opcode=0x929 & source0 & source1_cmpj & cmpj_target; seqword {
	if (source0 != source1_cmpj) goto cmpj_target;
	build seqword;
}

ucode_target: target is imm0 & imm1 & src1_sel [
	target = (((src1_sel & 0x07) << 13) | (imm1 << 8) | imm0) * $(INSTR_LEN);
] { export *[ucode]:8 target; }
#TODO: saveuip misses the semantics of the third source and dest
:saveuip uip_reg, ucode_target seqword is dst_sel=0 & (is_src0_imm=1|src0_sel=0) & dest & (opcode = 0x00c | opcode = 0x04c | opcode = 0x08c | opcode = 0x0cc) & uip_reg & ucode_target; seqword {
	uip_reg = &ucode_target/$(INSTR_LEN);
	build seqword;
}
:saveuip source0, uip_reg, ucode_target seqword is dst_sel=0 & is_src0_imm=0 & dest & source0 & (opcode = 0x00c | opcode = 0x04c | opcode = 0x08c | opcode = 0x0cc) & uip_reg & ucode_target; seqword {
	uip_reg = &ucode_target/$(INSTR_LEN);
	build seqword;
}
:saveuip dest uip_reg, ucode_target seqword is dest & (is_src0_imm=1|src0_sel=0) & (opcode = 0x00c | opcode = 0x04c | opcode = 0x08c | opcode = 0x0cc) & uip_reg & ucode_target; seqword {
	uip_reg = &ucode_target/$(INSTR_LEN);
	build seqword;
}
:saveuip dest source0, uip_reg, ucode_target seqword is dest & is_src0_imm=0 & source0 & (opcode = 0x00c | opcode = 0x04c | opcode = 0x08c | opcode = 0x0cc) & uip_reg & ucode_target; seqword {
	uip_reg = &ucode_target/$(INSTR_LEN);
	build seqword;
}

ucode_next:next is opcode [ next = inst_next; ] {
  export *[ucode]:8 next;
}
saveuip_ov_imm: value is imm0 & imm1 & src1_sel [
	value = (((src1_sel & 0x07) << 13) | (imm1 << 8) | imm0);
] { export *[const]:8 value; }
:saveuip_ov uip_reg, ucode_next, saveuip_ov_imm seqword is dst_sel=0 & saveuip_ov_imm & dest & opcode = 0x00d & uip_reg & ucode_next; seqword {
	uip_reg = &ucode_next/$(INSTR_LEN);
	build seqword;
}
# TODO: third_imm of SAVEUIP_REGOVR (no idea on semantics)
:saveuip_ov dest uip_reg, ucode_next, saveuip_ov_imm seqword is saveuip_ov_imm & dest & opcode = 0x00d & uip_reg & ucode_next; seqword {
	uip_reg = &ucode_next/$(INSTR_LEN);
	build seqword;
}

:uret uip_reg seqword is dst_sel=0 & dest & uip_reg & opcode=0x148; seqword {
	return [uip_reg*$(INSTR_LEN)];
}
#TODO: what is the semantics here?
:uret dest uip_reg, source0 seqword is dest & source0 & uip_reg & opcode=0x148; seqword {
	return [uip_reg*$(INSTR_LEN)];
}
